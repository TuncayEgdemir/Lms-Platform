import {
  getFullApiUrl
} from "./chunk-4PDGVH57.mjs";

// package.json
var package_default = {
  name: "uploadthing",
  version: "6.1.1",
  engines: {
    node: ">=18.13.0"
  },
  license: "MIT",
  exports: {
    "./package.json": "./package.json",
    "./client": {
      types: "./dist/client.d.ts",
      import: "./dist/client.mjs",
      require: "./dist/client.js"
    },
    "./server": {
      types: "./dist/server.d.ts",
      import: "./dist/server.mjs",
      require: "./dist/server.js"
    },
    "./next": {
      types: "./dist/next.d.ts",
      import: "./dist/next.mjs",
      require: "./dist/next.js"
    },
    "./next-legacy": {
      types: "./dist/next-legacy.d.ts",
      import: "./dist/next-legacy.mjs",
      require: "./dist/next-legacy.js"
    },
    "./express": {
      import: "./dist/express.mjs",
      types: "./dist/express.d.ts",
      require: "./dist/express.js"
    },
    "./tw": {
      types: "./dist/tw.d.ts",
      import: "./dist/tw.mjs",
      require: "./dist/tw.js"
    },
    "./fastify": {
      types: "./dist/fastify.d.ts",
      import: "./dist/fastify.mjs",
      require: "./dist/fastify.js"
    },
    "./h3": {
      types: "./dist/h3.d.ts",
      import: "./dist/h3.mjs",
      require: "./dist/h3.js"
    }
  },
  files: [
    "dist"
  ],
  publishConfig: {
    access: "public"
  },
  typesVersions: {
    "*": {
      client: [
        "dist/client.d.ts"
      ],
      server: [
        "dist/server.d.ts"
      ],
      next: [
        "dist/next.d.ts"
      ],
      "next-legacy": [
        "dist/next-legacy.d.ts"
      ],
      tw: [
        "dist/tw.d.ts"
      ],
      express: [
        "dist/express.d.ts"
      ],
      fastify: [
        "dist/fastify.d.ts"
      ],
      h3: [
        "dist/h3.d.ts"
      ]
    }
  },
  scripts: {
    lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
    build: "tsup",
    clean: "git clean -xdf dist node_modules",
    dev: "tsup --watch",
    test: "vitest run",
    "test:watch": "vitest",
    typecheck: "tsc --noEmit"
  },
  dependencies: {
    "@uploadthing/mime-types": "^0.2.2",
    "@uploadthing/shared": "^6.0.3"
  },
  devDependencies: {
    "@types/express": "^4.17.17",
    "@types/react": "18.2.33",
    "@uploadthing/eslint-config": "0.2.0",
    "@uploadthing/tsconfig": "0.1.0",
    "@uploadthing/tsup-config": "0.1.0",
    eslint: "^8.47.0",
    express: "^4.18.2",
    fastify: "^4.23.2",
    h3: "^1.8.1",
    next: "14.0.1",
    "solid-js": "^1.7.11",
    tailwindcss: "^3.3.2",
    tsup: "6.7.0",
    "type-fest": "^3.11.1",
    typescript: "^5.1.6",
    undici: "^5.20.0",
    vitest: "^0.30.1",
    zod: "^3.22.3"
  },
  eslintConfig: {
    root: true,
    extends: [
      "@uploadthing/eslint-config/base"
    ]
  }
};

// src/constants.ts
if (!package_default.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = package_default.version;

// src/internal/error-formatter.ts
function defaultErrorFormatter(error) {
  return {
    message: error.message
  };
}
function formatError(error, router) {
  var _a;
  const errorFormatter = ((_a = router[Object.keys(router)[0]]) == null ? void 0 : _a._def.errorFormatter) ?? defaultErrorFormatter;
  return errorFormatter(error);
}

// src/internal/types.ts
var unsetMarker = "unsetMarker";
var VALID_ACTION_TYPES = [
  "upload",
  "failure",
  "multipart-complete"
];

// src/internal/handler.ts
import {
  generateUploadThingURL as generateUploadThingURL2,
  getTypeFromFileName,
  isObject,
  objectKeys,
  fillInputRouteConfig as parseAndExpandInputConfig,
  safeParseJSON,
  UploadThingError as UploadThingError2
} from "@uploadthing/shared";

// src/internal/dev-hook.ts
import {
  generateUploadThingURL,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var conditionalDevServer = async (opts) => {
  if (process.env.NODE_ENV !== "development")
    return;
  const fileData = await pollForFileData(
    {
      url: generateUploadThingURL(`/api/pollUpload/${opts.fileKey}`),
      apiKey: opts.apiKey,
      sdkVersion: UPLOADTHING_VERSION
    },
    async (json) => {
      const file = json.fileData;
      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
      if (!callbackUrl.startsWith("http"))
        callbackUrl = "http://" + callbackUrl;
      console.log("[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
      const response = await fetch(callbackUrl, {
        method: "POST",
        body: JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,
            key: opts.fileKey,
            name: file.fileName,
            size: file.fileSize
          }
        }),
        headers: {
          "uploadthing-hook": "callback"
        }
      });
      if (isValidResponse(response)) {
        console.log(
          "[UT] Successfully simulated callback for file",
          opts.fileKey
        );
      } else {
        console.error(
          "[UT] Failed to simulate callback for file. Is your webhook configured correctly?",
          opts.fileKey
        );
      }
      return file;
    }
  );
  if (fileData !== void 0)
    return fileData;
  console.error(`[UT] Failed to simulate callback for file ${opts.fileKey}`);
  throw new UploadThingError({
    code: "UPLOAD_FAILED",
    message: "File took too long to upload"
  });
};

// src/internal/parser.ts
function getParseFn(parser) {
  if (typeof parser.parse === "function") {
    return parser.parse;
  }
  throw new Error("Invalid parser");
}

// src/internal/handler.ts
var createUTFetch = (apiKey) => {
  return async (endpoint, payload) => {
    const response = await fetch(generateUploadThingURL2(endpoint), {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
        "x-uploadthing-api-key": apiKey,
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
    return response;
  };
};
var fileCountLimitHit = (files, routeConfig) => {
  var _a;
  const counts = {};
  files.forEach((file) => {
    const type = getTypeFromFileName(file.name, objectKeys(routeConfig));
    if (!counts[type]) {
      counts[type] = 1;
    } else {
      counts[type] += 1;
    }
  });
  for (const _key in counts) {
    const key = _key;
    const count = counts[key];
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      console.error(routeConfig, key);
      throw new UploadThingError2({
        code: "BAD_REQUEST",
        message: "Invalid config during file count",
        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
      });
    }
    if (count > limit) {
      return { limitHit: true, type: key, limit, count };
    }
  }
  return { limitHit: false };
};
var getHeader = (req, key) => {
  if (req.headers instanceof Headers) {
    return req.headers.get(key);
  }
  return req.headers[key];
};
var buildRequestHandler = (opts) => {
  return async (input) => {
    var _a;
    if (process.env.NODE_ENV === "development") {
      console.log("[UT] UploadThing dev server is now running!");
    }
    const { req, res, event } = input;
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? process.env.UPLOADTHING_SECRET;
    let url;
    try {
      url = new URL(input.url ?? req.url ?? "");
    } catch (error) {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: `Invalid url '${((_a = input.url) == null ? void 0 : _a.href) ?? req.url}'`,
        cause: error
      });
    }
    const params = url.searchParams;
    const uploadthingHook = getHeader(req, "uploadthing-hook") ?? void 0;
    const slug = params.get("slug") ?? void 0;
    const actionType = params.get("actionType") ?? void 0;
    if (!slug)
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: "No slug provided"
      });
    if (slug && typeof slug !== "string") {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: "`slug` must be a string",
        cause: `Expected slug to be of type 'string', got '${typeof slug}'`
      });
    }
    if (actionType && typeof actionType !== "string") {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: "`actionType` must be a string",
        cause: `Expected actionType to be of type 'string', got '${typeof actionType}'`
      });
    }
    if (uploadthingHook && typeof uploadthingHook !== "string") {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: "`uploadthingHook` must be a string",
        cause: `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`
      });
    }
    if (!preferredOrEnvSecret) {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        message: `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,
        cause: "No secret provided"
      });
    }
    const uploadable = router[slug];
    if (!uploadable) {
      return new UploadThingError2({
        code: "NOT_FOUND",
        message: `No file route found for slug ${slug}`
      });
    }
    const utFetch = createUTFetch(preferredOrEnvSecret);
    if (uploadthingHook === "callback") {
      const maybeReqBody = await safeParseJSON(req);
      if (maybeReqBody instanceof Error) {
        return new UploadThingError2({
          code: "BAD_REQUEST",
          message: "Invalid request body",
          cause: maybeReqBody
        });
      }
      const res2 = await uploadable.resolver({
        file: maybeReqBody.file,
        metadata: maybeReqBody.metadata
      });
      await utFetch("/api/serverCallback", {
        fileKey: maybeReqBody.file.key,
        callbackData: res2 ?? null
      });
      return { status: 200 };
    }
    if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
      return new UploadThingError2({
        code: "BAD_REQUEST",
        cause: `Invalid action type ${actionType}`,
        message: `Expected ${VALID_ACTION_TYPES.map((x) => `"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${"a"}"`
      });
    }
    switch (actionType) {
      case "upload": {
        const maybeInput = await safeParseJSON(req);
        if (maybeInput instanceof Error) {
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeInput
          });
        }
        const { files, input: userInput } = maybeInput;
        let parsedInput = {};
        try {
          const inputParser = uploadable._def.inputParser;
          parsedInput = await getParseFn(inputParser)(userInput);
        } catch (error) {
          console.error(error);
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid input.",
            cause: error
          });
        }
        let metadata = {};
        try {
          metadata = await uploadable._def.middleware({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            req,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            res,
            event,
            input: parsedInput
          });
        } catch (error) {
          console.error(error);
          return new UploadThingError2({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run middleware.",
            cause: error
          });
        }
        if (!Array.isArray(files) || !files.every(
          (f) => isObject(f) && typeof f.name === "string" && typeof f.size === "number"
        ))
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Files must be an array of objects with name and size",
            cause: `Expected files to be of type '{name:string, size:number}[]', got '${JSON.stringify(
              files
            )}'`
          });
        let parsedConfig;
        try {
          parsedConfig = parseAndExpandInputConfig(
            uploadable._def.routerConfig
          );
        } catch (error) {
          console.error(error);
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        try {
          const { limitHit, count, limit, type } = fileCountLimitHit(
            files,
            parsedConfig
          );
          if (limitHit) {
            return new UploadThingError2({
              code: "BAD_REQUEST",
              message: "File limit exceeded",
              cause: `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`
            });
          }
        } catch (error) {
          console.error(error);
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        const callbackUrl = resolveCallbackUrl({ config, req, url });
        const uploadthingApiResponse = await utFetch("/api/prepareUpload", {
          files,
          routeConfig: parsedConfig,
          metadata,
          callbackUrl: callbackUrl.origin + callbackUrl.pathname,
          callbackSlug: slug
        });
        const parsedResponse = await safeParseJSON(
          uploadthingApiResponse
        );
        if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {
          console.error("[UT] unable to get presigned urls");
          return new UploadThingError2({
            code: "URL_GENERATION_FAILED",
            message: "Unable to get presigned urls",
            cause: parsedResponse
          });
        }
        if (process.env.NODE_ENV === "development") {
          for (const file of parsedResponse) {
            void conditionalDevServer({
              fileKey: file.key,
              apiKey: preferredOrEnvSecret
            });
          }
        }
        return {
          body: parsedResponse.map((x) => ({
            ...x,
            pollingUrl: generateUploadThingURL2(`/api/serverCallback`)
          })),
          status: 200
        };
      }
      case "multipart-complete": {
        const maybeReqBody = await safeParseJSON(req);
        if (maybeReqBody instanceof Error) {
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeReqBody
          });
        }
        const completeRes = await utFetch("/api/completeMultipart", {
          fileKey: maybeReqBody.fileKey,
          uploadId: maybeReqBody.uploadId,
          etags: maybeReqBody.etags
        });
        if (!completeRes.ok) {
          return new UploadThingError2({
            code: "UPLOAD_FAILED",
            message: "Failed to complete multipart upload"
          });
        }
        return { status: 200 };
      }
      case "failure": {
        const maybeReqBody = await safeParseJSON(req);
        if (maybeReqBody instanceof Error) {
          return new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeReqBody
          });
        }
        const { fileKey, uploadId } = maybeReqBody;
        const uploadthingApiResponse = await utFetch("/api/failureCallback", {
          fileKey,
          uploadId
        });
        if (!uploadthingApiResponse.ok) {
          console.error("[UT] failed to mark upload as failed");
          const parsedResponse = await safeParseJSON(
            uploadthingApiResponse
          );
          return new UploadThingError2({
            code: "INTERNAL_SERVER_ERROR",
            message: "Unable to mark upload as failed",
            cause: parsedResponse
          });
        }
        try {
          uploadable._def.onUploadError({
            error: new UploadThingError2({
              code: "UPLOAD_FAILED",
              message: `Upload failed for ${fileKey}`
            }),
            fileKey
          });
        } catch (error) {
          console.error(
            "[UT] Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback."
          );
          console.error(error);
          return new UploadThingError2({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run onUploadError callback",
            cause: error
          });
        }
        return { status: 200 };
      }
      default: {
        return new UploadThingError2({
          code: "BAD_REQUEST",
          message: `Invalid action type`
        });
      }
    }
  };
};
function resolveCallbackUrl(opts) {
  var _a, _b;
  let callbackUrl = opts.url;
  if ((_a = opts.config) == null ? void 0 : _a.callbackUrl) {
    callbackUrl = getFullApiUrl(opts.config.callbackUrl);
  } else if (process.env.UPLOADTHING_URL) {
    callbackUrl = getFullApiUrl(process.env.UPLOADTHING_URL);
  }
  if (process.env.NODE_ENV !== "production" || !callbackUrl.host.includes("localhost")) {
    return callbackUrl;
  }
  let parsedFromHeaders = (_b = getHeader(opts.req, "origin") ?? getHeader(opts.req, "referer") ?? getHeader(opts.req, "host") ?? getHeader(opts.req, "x-forwarded-host")) == null ? void 0 : _b.toString();
  if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
    parsedFromHeaders = (getHeader(opts.req, "x-forwarded-proto") ?? "https").toString() + "://" + parsedFromHeaders;
  }
  if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
    console.warn(
      [
        "[UT] [WARN] You are using a localhost callback url in production which is not supported.",
        "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production"
      ].join(" ")
    );
    return callbackUrl;
  }
  return getFullApiUrl(parsedFromHeaders);
}
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = parseAndExpandInputConfig(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

// src/internal/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    inputParser: { parse: () => ({}), _input: {}, _output: {} },
    middleware: () => ({}),
    onUploadError: () => ({}),
    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
    // Overload with properties passed in
    ...initDef
  };
  return {
    input(userParser) {
      return internalCreateBuilder({
        ..._def,
        inputParser: userParser
      });
    },
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    },
    onUploadError(userOnUploadError) {
      return internalCreateBuilder({
        ..._def,
        onUploadError: userOnUploadError
      });
    }
  };
}
function createBuilder(opts) {
  return (input) => {
    return internalCreateBuilder({
      routerConfig: input,
      ...opts
    });
  };
}

export {
  UPLOADTHING_VERSION,
  defaultErrorFormatter,
  formatError,
  unsetMarker,
  VALID_ACTION_TYPES,
  buildRequestHandler,
  buildPermissionsInfoHandler,
  createBuilder
};
//# sourceMappingURL=chunk-3K3M4GBL.mjs.map