import {
  incompatibleNodeGuard
} from "./chunk-WPSY3MFJ.mjs";
import {
  UPLOADTHING_VERSION,
  buildPermissionsInfoHandler,
  buildRequestHandler,
  createBuilder,
  formatError
} from "./chunk-3K3M4GBL.mjs";
import "./chunk-4PDGVH57.mjs";

// src/express.ts
import { Router as ExpressRouter } from "express";
import { getStatusCodeFromError, UploadThingError as UploadThingError2 } from "@uploadthing/shared";

// src/internal/node-http/getBody.ts
import { UploadThingError } from "@uploadthing/shared";
async function getPostBody(opts) {
  const { req, maxBodySize = Infinity } = opts;
  return new Promise((resolve) => {
    if ("body" in req) {
      const isJsonType = req.headers["content-type"] === "application/json";
      if (!isJsonType) {
        resolve({
          ok: false,
          error: new UploadThingError({
            code: "BAD_REQUEST",
            message: "INVALID_CONTENT_TYPE"
          })
        });
        return;
      }
      if (typeof req.body !== "object") {
        resolve({
          ok: false,
          error: new UploadThingError({
            code: "BAD_REQUEST",
            message: "INVALID_BODY"
          })
        });
        return;
      }
      resolve({
        ok: true,
        data: req.body
      });
      return;
    }
    let body = "";
    let hasBody = false;
    req.on("data", function(data) {
      body += data;
      hasBody = true;
      if (body.length > maxBodySize) {
        resolve({
          ok: false,
          error: new UploadThingError({
            code: "BAD_REQUEST",
            message: "PAYLOAD_TOO_LARGE"
          })
        });
        req.socket.destroy();
      }
    });
    req.on("end", () => {
      let parsedBody;
      try {
        parsedBody = JSON.parse(body);
      } catch (e) {
        resolve({
          ok: false,
          error: new UploadThingError({
            code: "BAD_REQUEST",
            message: "INVALID_JSON"
          })
        });
        return;
      }
      resolve({
        ok: true,
        data: hasBody ? parsedBody : void 0
      });
    });
  });
}

// src/express.ts
var createUploadthing = (opts) => createBuilder(opts);
var createUploadthingExpressHandler = (opts) => {
  incompatibleNodeGuard();
  const requestHandler = buildRequestHandler(opts);
  const router = ExpressRouter();
  router.post("/", async (req, res) => {
    const bodyResult = await getPostBody({ req });
    if (!bodyResult.ok) {
      res.status(400);
      res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
      res.send(
        JSON.stringify({
          error: "BAD_REQUEST",
          message: bodyResult.error.message
        })
      );
      return;
    }
    const proto = req.headers["x-forwarded-proto"] ?? "http";
    const url = new URL(
      req.baseUrl + req.url,
      // baseUrl is the mount point for the router, url is the path
      `${proto}://${req.headers.host}`
    );
    const response = await requestHandler({
      req: Object.assign(req, {
        json: () => Promise.resolve(bodyResult.data)
      }),
      url,
      res
    });
    if (response instanceof UploadThingError2) {
      res.status(getStatusCodeFromError(response));
      res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
      res.send(JSON.stringify(formatError(response, opts.router)));
      return;
    }
    if (response.status !== 200) {
      res.status(500);
      res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
      res.send("An unknown error occured");
      return;
    }
    res.status(response.status);
    res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
    res.send(JSON.stringify(response.body));
  });
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  router.get("/", (_req, res) => {
    res.status(200);
    res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
    res.send(JSON.stringify(getBuildPerms()));
  });
  return router;
};
export {
  createUploadthing,
  createUploadthingExpressHandler
};
//# sourceMappingURL=express.mjs.map