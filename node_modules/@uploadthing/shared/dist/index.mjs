// src/utils.ts
import { lookup } from "@uploadthing/mime-types";
function isRouteArray(routeConfig) {
  return Array.isArray(routeConfig);
}
function getDefaultSizeForType(fileType) {
  if (fileType === "image")
    return "4MB";
  if (fileType === "video")
    return "16MB";
  if (fileType === "audio")
    return "8MB";
  if (fileType === "blob")
    return "8MB";
  if (fileType === "pdf")
    return "4MB";
  if (fileType === "text")
    return "64KB";
  return "4MB";
}
function fillInputRouteConfig(routeConfig) {
  if (isRouteArray(routeConfig)) {
    return routeConfig.reduce((acc, fileType) => {
      acc[fileType] = {
        // Apply defaults
        maxFileSize: getDefaultSizeForType(fileType),
        maxFileCount: 1,
        contentDisposition: "inline"
      };
      return acc;
    }, {});
  }
  const newConfig = {};
  const inputKeys = objectKeys(routeConfig);
  inputKeys.forEach((key) => {
    const value = routeConfig[key];
    if (!value)
      throw new Error("Invalid config during fill");
    const defaultValues = {
      maxFileSize: getDefaultSizeForType(key),
      maxFileCount: 1,
      contentDisposition: "inline"
    };
    newConfig[key] = { ...defaultValues, ...value };
  }, {});
  return newConfig;
}
function getTypeFromFileName(fileName, allowedTypes) {
  const mimeType = lookup(fileName);
  if (!mimeType) {
    if (allowedTypes.includes("blob"))
      return "blob";
    throw new Error(
      `Could not determine type for ${fileName}, presigned URL generation failed`
    );
  }
  if (allowedTypes.some((type2) => type2.includes("/"))) {
    if (allowedTypes.includes(mimeType)) {
      return mimeType;
    }
  }
  const type = mimeType.toLowerCase() === "application/pdf" ? "pdf" : mimeType.split("/")[0];
  if (!allowedTypes.includes(type)) {
    if (allowedTypes.includes("blob")) {
      return "blob";
    } else {
      throw new Error(`File type ${type} not allowed for ${fileName}`);
    }
  }
  return type;
}
function generateUploadThingURL(path) {
  var _a;
  let host = "https://uploadthing.com";
  if (typeof process !== "undefined") {
    host = process.env.CUSTOM_INFRA_URL ?? host;
  } else {
    host = ((_a = import.meta.env) == null ? void 0 : _a.CUSTOM_INFRA_URL) ?? host;
  }
  return `${host}${path}`;
}
var withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1e3, MAX_RETRIES = 20) => {
  let tries = 0;
  let backoffMs = 500;
  let backoffFuzzMs = 0;
  let result = void 0;
  while (tries <= MAX_RETRIES) {
    result = await doTheThing();
    if (result !== void 0)
      return result;
    tries += 1;
    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);
    backoffFuzzMs = Math.floor(Math.random() * 500);
    if (tries > 3) {
      console.error(
        `[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(
          backoffMs / 1e3
        )} seconds...`
      );
    }
    await new Promise((r) => setTimeout(r, backoffMs + backoffFuzzMs));
  }
  return null;
};
async function pollForFileData(opts, callback) {
  return withExponentialBackoff(async () => {
    const res = await fetch(opts.url, {
      headers: {
        ...opts.apiKey && { "x-uploadthing-api-key": opts.apiKey },
        "x-uploadthing-version": opts.sdkVersion
      }
    });
    const maybeJson = await safeParseJSON(res);
    if (maybeJson instanceof Error) {
      console.error(
        `[UT] Error polling for file data for ${opts.url}: ${maybeJson.message}`
      );
      return null;
    }
    if (maybeJson.status !== "done")
      return void 0;
    await (callback == null ? void 0 : callback(maybeJson));
    return Symbol("backoff done without response");
  });
}
var FILESIZE_UNITS = ["B", "KB", "MB", "GB"];
var fileSizeToBytes = (input) => {
  const regex = new RegExp(
    `^(\\d+)(\\.\\d+)?\\s*(${FILESIZE_UNITS.join("|")})$`,
    "i"
  );
  const match = input.match(regex);
  if (!match) {
    return new Error("Invalid file size format");
  }
  const sizeValue = parseFloat(match[1]);
  const sizeUnit = match[3].toUpperCase();
  if (!FILESIZE_UNITS.includes(sizeUnit)) {
    throw new Error("Invalid file size unit");
  }
  const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));
  return Math.floor(bytes);
};
async function safeParseJSON(input) {
  var _a;
  if (typeof input === "string") {
    try {
      return JSON.parse(input);
    } catch (err) {
      console.error(`Error parsing JSON, got '${input}'`);
      return new Error(`Error parsing JSON, got '${input}'`);
    }
  }
  const clonedRes = (_a = input.clone) == null ? void 0 : _a.call(input);
  try {
    return await input.json();
  } catch (err) {
    const text = await (clonedRes == null ? void 0 : clonedRes.text()) ?? "unknown";
    console.error(`Error parsing JSON, got '${text}'`);
    return new Error(`Error parsing JSON, got '${text}'`);
  }
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}

// src/file-types.ts
var ALLOWED_FILE_TYPES = [
  "image",
  "video",
  "audio",
  "pdf",
  "text",
  "blob"
];

// src/error.ts
var ERROR_CODES = {
  // Generic
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  INTERNAL_SERVER_ERROR: 500,
  INTERNAL_CLIENT_ERROR: 500,
  // S3 specific
  TOO_LARGE: 413,
  TOO_SMALL: 400,
  TOO_MANY_FILES: 400,
  KEY_TOO_LONG: 400,
  // UploadThing specific
  URL_GENERATION_FAILED: 500,
  UPLOAD_FAILED: 500,
  MISSING_ENV: 500,
  FILE_LIMIT_EXCEEDED: 500
};
function messageFromUnknown(cause, fallback) {
  if (typeof cause === "string") {
    return cause;
  }
  if (cause instanceof Error) {
    return cause.message;
  }
  if (cause && typeof cause === "object" && "message" in cause && typeof cause.message === "string") {
    return cause.message;
  }
  return fallback ?? "An unknown error occurred";
}
var UploadThingError = class extends Error {
  constructor(opts) {
    const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);
    super(message);
    this.code = opts.code;
    this.data = opts.data;
    if (opts.cause instanceof Error) {
      this.cause = opts.cause;
    } else if (opts.cause instanceof Response) {
      this.cause = new Error(
        `Response ${opts.cause.status} ${opts.cause.statusText}`
      );
    } else if (typeof opts.cause === "string") {
      this.cause = new Error(opts.cause);
    } else {
      this.cause = void 0;
    }
  }
  static async fromResponse(response) {
    const jsonOrError = await safeParseJSON(response);
    if (jsonOrError instanceof Error) {
      return new UploadThingError({
        message: jsonOrError.message,
        code: getErrorTypeFromStatusCode(response.status),
        cause: response
      });
    }
    let message = void 0;
    if (isObject(jsonOrError)) {
      if (typeof jsonOrError.message === "string") {
        message = jsonOrError.message;
      } else if (typeof jsonOrError.error === "string") {
        message = jsonOrError.error;
      }
    }
    return new UploadThingError({
      message,
      code: getErrorTypeFromStatusCode(response.status),
      cause: response,
      data: jsonOrError
    });
  }
  static toObject(error) {
    return {
      code: error.code,
      message: error.message,
      data: error.data
    };
  }
  static serialize(error) {
    return JSON.stringify(UploadThingError.toObject(error));
  }
};
function getStatusCodeFromError(error) {
  return ERROR_CODES[error.code] ?? 500;
}
function getErrorTypeFromStatusCode(statusCode) {
  for (const [code, status] of Object.entries(ERROR_CODES)) {
    if (status === statusCode) {
      return code;
    }
  }
  return "INTERNAL_SERVER_ERROR";
}
export {
  ALLOWED_FILE_TYPES,
  FILESIZE_UNITS,
  UploadThingError,
  fileSizeToBytes,
  fillInputRouteConfig,
  generateUploadThingURL,
  getDefaultSizeForType,
  getStatusCodeFromError,
  getTypeFromFileName,
  isObject,
  isRouteArray,
  objectKeys,
  pollForFileData,
  safeParseJSON,
  withExponentialBackoff
};
//# sourceMappingURL=index.mjs.map