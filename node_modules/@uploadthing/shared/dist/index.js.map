{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/file-types.ts","../src/error.ts"],"sourcesContent":["export * from \"./types\";\nexport * from \"./utils\";\nexport * from \"./file-types\";\nexport * from \"./error\";\n","import { lookup } from \"@uploadthing/mime-types\";\n\nimport type { AllowedFileType } from \"./file-types\";\nimport type {\n  ExpandedRouteConfig,\n  FileData,\n  FileRouterInputConfig,\n  FileRouterInputKey,\n  FileSize,\n  RequestLike,\n  ResponseEsque,\n} from \"./types\";\n\nexport function isRouteArray(\n  routeConfig: FileRouterInputConfig,\n): routeConfig is FileRouterInputKey[] {\n  return Array.isArray(routeConfig);\n}\n\nexport function getDefaultSizeForType(fileType: FileRouterInputKey): FileSize {\n  if (fileType === \"image\") return \"4MB\";\n  if (fileType === \"video\") return \"16MB\";\n  if (fileType === \"audio\") return \"8MB\";\n  if (fileType === \"blob\") return \"8MB\";\n  if (fileType === \"pdf\") return \"4MB\";\n  if (fileType === \"text\") return \"64KB\";\n\n  return \"4MB\";\n}\n\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */\nexport function fillInputRouteConfig(\n  routeConfig: FileRouterInputConfig,\n): ExpandedRouteConfig {\n  // If array, apply defaults\n  if (isRouteArray(routeConfig)) {\n    return routeConfig.reduce<ExpandedRouteConfig>((acc, fileType) => {\n      acc[fileType] = {\n        // Apply defaults\n        maxFileSize: getDefaultSizeForType(fileType),\n        maxFileCount: 1,\n        contentDisposition: \"inline\",\n      };\n      return acc;\n    }, {});\n  }\n\n  // Backfill defaults onto config\n  const newConfig: ExpandedRouteConfig = {};\n  const inputKeys = objectKeys(routeConfig);\n  inputKeys.forEach((key) => {\n    const value = routeConfig[key];\n    if (!value) throw new Error(\"Invalid config during fill\");\n\n    const defaultValues = {\n      maxFileSize: getDefaultSizeForType(key),\n      maxFileCount: 1,\n      contentDisposition: \"inline\" as const,\n    };\n\n    newConfig[key] = { ...defaultValues, ...value };\n  }, {} as ExpandedRouteConfig);\n\n  return newConfig;\n}\n\nexport function getTypeFromFileName(\n  fileName: string,\n  allowedTypes: FileRouterInputKey[],\n) {\n  const mimeType = lookup(fileName);\n  if (!mimeType) {\n    if (allowedTypes.includes(\"blob\")) return \"blob\";\n    throw new Error(\n      `Could not determine type for ${fileName}, presigned URL generation failed`,\n    );\n  }\n\n  // If the user has specified a specific mime type, use that\n  if (allowedTypes.some((type) => type.includes(\"/\"))) {\n    if (allowedTypes.includes(mimeType)) {\n      return mimeType;\n    }\n  }\n\n  // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n  const type = (\n    mimeType.toLowerCase() === \"application/pdf\"\n      ? \"pdf\"\n      : mimeType.split(\"/\")[0]\n  ) as AllowedFileType;\n\n  if (!allowedTypes.includes(type)) {\n    // Blob is a catch-all for any file type not explicitly supported\n    if (allowedTypes.includes(\"blob\")) {\n      return \"blob\";\n    } else {\n      throw new Error(`File type ${type} not allowed for ${fileName}`);\n    }\n  }\n\n  return type;\n}\n\nexport function generateUploadThingURL(path: `/${string}`) {\n  let host = \"https://uploadthing.com\";\n\n  if (typeof process !== \"undefined\") {\n    host = process.env.CUSTOM_INFRA_URL ?? host;\n  } else {\n    // @ts-expect-error - import.meta is dumb\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n    host = import.meta.env?.CUSTOM_INFRA_URL ?? host;\n  }\n  return `${host}${path}`;\n}\n\n/**\n * RETURN UNDEFINED TO KEEP GOING\n * SO MAKE SURE YOUR FUNCTION RETURNS SOMETHING\n * OTHERWISE IT'S AN IMPLICIT UNDEFINED AND WILL CAUSE\n * AN INFINITE LOOP\n */\nexport const withExponentialBackoff = async <T>(\n  doTheThing: () => Promise<T | undefined>,\n  MAXIMUM_BACKOFF_MS = 64 * 1000,\n  MAX_RETRIES = 20,\n): Promise<T | null> => {\n  let tries = 0;\n  let backoffMs = 500;\n  let backoffFuzzMs = 0;\n\n  let result = undefined;\n  while (tries <= MAX_RETRIES) {\n    result = await doTheThing();\n    if (result !== undefined) return result;\n\n    tries += 1;\n    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);\n    backoffFuzzMs = Math.floor(Math.random() * 500);\n\n    if (tries > 3) {\n      console.error(\n        `[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(\n          backoffMs / 1000,\n        )} seconds...`,\n      );\n    }\n\n    await new Promise((r) => setTimeout(r, backoffMs + backoffFuzzMs));\n  }\n\n  return null;\n};\n\nexport async function pollForFileData(\n  opts: {\n    url: string;\n    // no apikey => no filedata will be returned, just status\n    apiKey: string | null;\n    sdkVersion: string;\n  },\n  callback?: (json: any) => Promise<any>,\n) {\n  return withExponentialBackoff(async () => {\n    const res = await fetch(opts.url, {\n      headers: {\n        ...(opts.apiKey && { \"x-uploadthing-api-key\": opts.apiKey }),\n        \"x-uploadthing-version\": opts.sdkVersion,\n      },\n    });\n    const maybeJson = await safeParseJSON<\n      { status: \"done\"; fileData?: FileData } | { status: \"something else\" }\n    >(res);\n\n    if (maybeJson instanceof Error) {\n      console.error(\n        `[UT] Error polling for file data for ${opts.url}: ${maybeJson.message}`,\n      );\n      return null;\n    }\n\n    if (maybeJson.status !== \"done\") return undefined;\n    await callback?.(maybeJson);\n\n    return Symbol(\"backoff done without response\");\n  });\n}\n\nexport const FILESIZE_UNITS = [\"B\", \"KB\", \"MB\", \"GB\"] as const;\nexport type FileSizeUnit = (typeof FILESIZE_UNITS)[number];\nexport const fileSizeToBytes = (input: string) => {\n  const regex = new RegExp(\n    `^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`,\n    \"i\",\n  );\n  const match = input.match(regex);\n\n  if (!match) {\n    return new Error(\"Invalid file size format\");\n  }\n\n  const sizeValue = parseFloat(match[1]);\n  const sizeUnit = match[3].toUpperCase() as FileSizeUnit;\n\n  if (!FILESIZE_UNITS.includes(sizeUnit)) {\n    throw new Error(\"Invalid file size unit\");\n  }\n  const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n  return Math.floor(bytes);\n};\n\nexport async function safeParseJSON<T>(\n  input: string | ResponseEsque | RequestLike,\n): Promise<T | Error> {\n  if (typeof input === \"string\") {\n    try {\n      return JSON.parse(input) as T;\n    } catch (err) {\n      console.error(`Error parsing JSON, got '${input}'`);\n      return new Error(`Error parsing JSON, got '${input}'`);\n    }\n  }\n\n  const clonedRes = input.clone?.();\n  try {\n    return (await input.json()) as T;\n  } catch (err) {\n    const text = (await clonedRes?.text()) ?? \"unknown\";\n    console.error(`Error parsing JSON, got '${text}'`);\n    return new Error(`Error parsing JSON, got '${text}'`);\n  }\n}\n\n/** typesafe Object.keys */\nexport function objectKeys<T extends Record<string, unknown>>(\n  obj: T,\n): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[];\n}\n\n/** checks if obj is a valid, non-null object */\nexport function isObject(obj: unknown): obj is Record<string, unknown> {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\n","export const ALLOWED_FILE_TYPES = [\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"pdf\",\n  \"text\",\n  \"blob\",\n] as const;\n\nexport type AllowedFileType = (typeof ALLOWED_FILE_TYPES)[number];\n","import type { Json, ResponseEsque } from \"./types\";\nimport { isObject, safeParseJSON } from \"./utils\";\n\nconst ERROR_CODES = {\n  // Generic\n  BAD_REQUEST: 400,\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  INTERNAL_SERVER_ERROR: 500,\n  INTERNAL_CLIENT_ERROR: 500,\n\n  // S3 specific\n  TOO_LARGE: 413,\n  TOO_SMALL: 400,\n  TOO_MANY_FILES: 400,\n  KEY_TOO_LONG: 400,\n\n  // UploadThing specific\n  URL_GENERATION_FAILED: 500,\n  UPLOAD_FAILED: 500,\n  MISSING_ENV: 500,\n  FILE_LIMIT_EXCEEDED: 500,\n} as const;\n\ntype ErrorCode = keyof typeof ERROR_CODES;\n\nfunction messageFromUnknown(cause: unknown, fallback?: string) {\n  if (typeof cause === \"string\") {\n    return cause;\n  }\n  if (cause instanceof Error) {\n    return cause.message;\n  }\n  if (\n    cause &&\n    typeof cause === \"object\" &&\n    \"message\" in cause &&\n    typeof cause.message === \"string\"\n  ) {\n    return cause.message;\n  }\n  return fallback ?? \"An unknown error occurred\";\n}\n\nexport class UploadThingError<\n  TShape extends Json = { message: string },\n> extends Error {\n  public readonly cause?: Error;\n  public readonly code: ErrorCode;\n  public readonly data?: TShape;\n\n  constructor(opts: {\n    code: keyof typeof ERROR_CODES;\n    message?: string;\n    cause?: unknown;\n    data?: TShape;\n  }) {\n    const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n\n    super(message);\n    this.code = opts.code;\n    this.data = opts.data;\n\n    if (opts.cause instanceof Error) {\n      this.cause = opts.cause;\n    } else if (opts.cause instanceof Response) {\n      this.cause = new Error(\n        `Response ${opts.cause.status} ${opts.cause.statusText}`,\n      );\n    } else if (typeof opts.cause === \"string\") {\n      this.cause = new Error(opts.cause);\n    } else {\n      this.cause = undefined;\n    }\n  }\n\n  public static async fromResponse(response: ResponseEsque) {\n    const jsonOrError = await safeParseJSON<Json>(response);\n    if (jsonOrError instanceof Error) {\n      return new UploadThingError({\n        message: jsonOrError.message,\n        code: getErrorTypeFromStatusCode(response.status),\n        cause: response,\n      });\n    }\n\n    let message: string | undefined = undefined;\n    if (isObject(jsonOrError)) {\n      if (typeof jsonOrError.message === \"string\") {\n        message = jsonOrError.message;\n      } else if (typeof jsonOrError.error === \"string\") {\n        message = jsonOrError.error;\n      }\n    }\n    return new UploadThingError({\n      message,\n      code: getErrorTypeFromStatusCode(response.status),\n      cause: response,\n      data: jsonOrError,\n    });\n  }\n\n  public static toObject(error: UploadThingError) {\n    return {\n      code: error.code,\n      message: error.message,\n      data: error.data,\n    };\n  }\n\n  public static serialize(error: UploadThingError) {\n    return JSON.stringify(UploadThingError.toObject(error));\n  }\n}\n\nexport function getStatusCodeFromError(error: UploadThingError<any>) {\n  return ERROR_CODES[error.code] ?? 500;\n}\n\nfunction getErrorTypeFromStatusCode(statusCode: number): ErrorCode {\n  for (const [code, status] of Object.entries(ERROR_CODES)) {\n    if (status === statusCode) {\n      return code as ErrorCode;\n    }\n  }\n  return \"INTERNAL_SERVER_ERROR\";\n}\n"],"mappings":"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","names":["type"]}